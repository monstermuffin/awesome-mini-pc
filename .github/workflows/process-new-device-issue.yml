name: Process New Device Issue

on:
  issues:
    types:
      - labeled

jobs:
  create_device_yaml:
    if: github.event.label.name == 'new-device'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse Issue Form and Create YAML
        id: parse_issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const issueBody = issue.data.body;
            if (!issueBody) {
              throw new Error('Issue body is empty');
            }

            // Parse the issue form
            const lines = issueBody.split('\n');
            const data = {};
            let currentField = null;
            let currentValue = '';

            // Field mapping from form IDs to YAML fields
            const fieldMapping = {
              'id': 'device_id',
              'brand': 'brand',
              'model': 'model',
              'release_date': 'release_date',
              'cpu_brand': 'cpu_brand',
              'cpu_model': 'cpu_model',
              'cpu_tdp': 'cpu_tdp',
              'cpu_cores': 'cpu_cores',
              'cpu_threads': 'cpu_threads',
              'cpu_base_clock': 'base_clock_ghz',
              'cpu_boost_clock': 'boost_clock_ghz',
              'cpu_architecture': 'cpu_architecture',
              'cpu_socket_type': 'cpu_socket_type',
              'memory_type': 'memory_type',
              'memory_module_type': 'memory_module_type',
              'memory_slots': 'memory_slots',
              'memory_max': 'maximum_memory_capacity_gb',
              'memory_speed': 'memory_speed_mhz',
              'storage_details': 'storage_details',
              'wifi_standard': 'wifi_standard',
              'wifi_chipset': 'wifi_chipset'
            };

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              
              // Skip empty lines and headers
              if (!line || line.startsWith('#') || line.startsWith('_No response_')) {
                continue;
              }
              
              // Check if this is a field label
              for (const [formId, yamlField] of Object.entries(fieldMapping)) {
                if (line.includes(`### ${formId}`)) {
                  // Save previous field if exists
                  if (currentField && currentValue) {
                    data[fieldMapping[currentField]] = currentValue.trim();
                  }
                  
                  // Start new field
                  currentField = formId;
                  currentValue = '';
                  break;
                }
              }
              
              // If not a field label, append to current value
              if (!line.startsWith('###') && currentField) {
                if (currentValue) {
                  currentValue += '\n';
                }
                currentValue += line;
              }
            }
            
            // Save last field
            if (currentField && currentValue) {
              data[fieldMapping[currentField]] = currentValue.trim();
            }

            console.log("Parsed data:", data);

            // Validation
            const errors = [];
            const requiredFields = [
              'device_id', 'brand', 'model', 'release_date', 'cpu_brand', 'cpu_model',
              'cpu_tdp', 'memory_type', 'memory_module_type', 'memory_slots',
              'maximum_memory_capacity_gb', 'memory_speed_mhz', 'storage_details'
            ];

            requiredFields.forEach(field => {
              if (!data[field]) {
                errors.push(`Missing required field: \`${field.replace(/_/g, ' ')}\``);
              }
            });

            // Check if errors were found
            if (errors.length > 0) {
              const errorBody = `Failed to process submission due to validation errors:\\n\\n- ${errors.join('\\n- ')}\\n\\nPlease edit the issue body to correct these errors. The automation will attempt to process it again once updated.`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: errorBody
              });
              core.setFailed('Validation errors found in issue form.');
              return;
            }

            // Convert data to YAML format
            const deviceData = {
              id: data.device_id,
              brand: data.brand,
              model: data.model,
              release_date: parseInt(data.release_date),
              cpu: {
                brand: data.cpu_brand,
                model: data.cpu_model,
                tdp: parseInt(data.cpu_tdp),
                cores: data.cpu_cores ? parseInt(data.cpu_cores) : undefined,
                threads: data.cpu_threads ? parseInt(data.cpu_threads) : undefined,
                base_clock_ghz: data.base_clock_ghz ? parseFloat(data.base_clock_ghz) : undefined,
                boost_clock_ghz: data.boost_clock_ghz ? parseFloat(data.boost_clock_ghz) : undefined,
                architecture: data.cpu_architecture,
                socket_type: data.cpu_socket_type !== 'N/A (Non-DIY system)' ? data.cpu_socket_type : undefined
              },
              memory: {
                type: data.memory_type,
                module_type: data.memory_module_type,
                slots: parseInt(data.memory_slots),
                max_capacity_gb: parseInt(data.maximum_memory_capacity_gb),
                speed_mhz: parseInt(data.memory_speed_mhz)
              }
            };

            // Parse GPU models if present
            if (data.gpu_models) {
              deviceData.gpu = data.gpu_models.split('\n')
                .filter(line => line.trim().startsWith('-'))
                .map(line => {
                  const parts = line.substring(1).split(',').map(p => p.trim());
                  const gpu = {};
                  parts.forEach(part => {
                    const [key, value] = part.split(':').map(s => s.trim());
                    if (key.toLowerCase() === 'type') gpu.type = value;
                    if (key.toLowerCase() === 'model') gpu.model = value;
                    if (key.toLowerCase() === 'vram') gpu.vram = value;
                  });
                  return gpu;
                });
            }

            // Parse storage details
            deviceData.storage = data.storage_details.split('\n')
              .filter(line => line.trim().startsWith('-'))
              .map(line => {
                const parts = line.substring(1).split(',').map(p => p.trim());
                const storage = {};
                parts.forEach(part => {
                  const [key, value] = part.split(':').map(s => s.trim());
                  storage[key.toLowerCase().replace(/ /g, '_')] = value;
                });
                return storage;
              });

            // Add networking if present
            deviceData.networking = {
              wifi: data.wifi_standard ? {
                standard: data.wifi_standard,
                chipset: data.wifi_chipset
              } : undefined
            };

            const yaml = require('js-yaml');
            const yamlString = yaml.dump(deviceData, { indent: 2, skipInvalid: true });

            // Determine file path based on brand
            const brand = data.brand.toLowerCase();
            const filePath = `data/devices/${brand}/${data.device_id}.yaml`;
            const dirPath = require('path').dirname(filePath);

            // Create directory if it doesn't exist
            if (!fs.existsSync(dirPath)) {
              fs.mkdirSync(dirPath, { recursive: true });
            }

            // Write YAML file
            fs.writeFileSync(filePath, yamlString);

            // Set outputs for PR creation
            core.setOutput('file_path', filePath);
            core.setOutput('branch_name', `new-device/${data.device_id}`);
            core.setOutput('commit_message', `Add device data for ${data.brand} ${data.model}`);
            core.setOutput('pr_title', `Add Device: ${data.brand} ${data.model}`);
            core.setOutput('pr_body', `Adds data for **${data.brand} ${data.model}** based on issue #${context.issue.number}.\n\nCloses #${context.issue.number}`);

      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: ${{ steps.parse_issue.outputs.commit_message }}
          branch: ${{ steps.parse_issue.outputs.branch_name }}
          delete-branch: true
          title: ${{ steps.parse_issue.outputs.pr_title }}
          body: ${{ steps.parse_issue.outputs.pr_body }}
          labels: new-device, automated-pr
          assignees: ${{ github.actor }}

      - name: Comment on Issue with PR Link
        uses: actions/github-script@v7
        if: steps.create_pr.outputs.pull-request-number
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `Thank you for your submission! A Pull Request has been created: #${steps.create_pr.outputs.pull-request-number}`
            }); 