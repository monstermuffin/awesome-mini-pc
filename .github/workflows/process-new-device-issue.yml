name: Process New Device Issue

on:
  issues:
    types:
      - labeled

jobs:
  create_device_yaml:
    if: github.event.label.name == 'new-device'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install js-yaml

      - name: Parse Issue Form and Create YAML
        id: parse_issue
        uses: actions/github-script@v7
        with:
          script: |
            const yaml = require('js-yaml');
            
            async function createPR() {
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const issueBody = issue.data.body;
              if (!issueBody) {
                throw new Error('Issue body is empty');
              }

              // Parse the issue form
              const lines = issueBody.split('\n');
              const data = {};
              
              // Field mapping from form fields to YAML fields
              const fieldMapping = {
                'Device ID': 'device_id',
                'Brand': 'brand',
                'Model': 'model',
                'Release Date': 'release_date',
                'CPU Brand': 'cpu_brand',
                'CPU Model': 'cpu_model',
                'CPU TDP (Watts)': 'cpu_tdp',
                'CPU Cores': 'cpu_cores',
                'CPU Threads': 'cpu_threads',
                'Base Clock (GHz)': 'base_clock_ghz',
                'Boost Clock (GHz)': 'boost_clock_ghz',
                'CPU Architecture': 'cpu_architecture',
                'CPU Socket Type': 'cpu_socket_type',
                'GPU Models': 'gpu_models',
                'Memory Type': 'memory_type',
                'Memory Module Type': 'memory_module_type',
                'Memory Slots': 'memory_slots',
                'Maximum Memory Capacity (GB)': 'maximum_memory_capacity_gb',
                'Memory Speed (MHz)': 'memory_speed_mhz',
                'Storage Details': 'storage_details',
                'WiFi Standard': 'wifi_standard',
                'WiFi Chipset': 'wifi_chipset',
                'Bluetooth Version': 'bluetooth_version',
                'Ethernet Ports': 'ethernet_ports',
                'PCIe Slots': 'pcie_slots',
                'OCuLink Ports': 'oculink_ports',
                'USB Ports': 'usb_ports',
                'Display Ports': 'display_ports',
                'Audio Jacks': 'audio_jacks',
                'SD Card Reader': 'sd_card_reader',
                'Dimensions (mm)': 'dimensions',
                'Power Adapter': 'power_adapter',
                'Additional Information': 'additional_info'
              };

              let currentField = null;
              let currentValue = [];

              // Process each line
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Skip empty lines and confirmation section
                if (!line || line === 'Description' || line === 'Submission Confirmation') {
                  continue;
                }

                // Check if this is a field header
                if (line.startsWith('### ')) {
                  // Save previous field if exists
                  if (currentField && currentValue.length > 0) {
                    const fieldName = fieldMapping[currentField];
                    if (fieldName) {
                      data[fieldName] = currentValue.join('\n').trim();
                    }
                  }
                  
                  // Start new field
                  currentField = line.substring(4);
                  currentValue = [];
                  continue;
                }

                // Skip "No response" values
                if (line === '_No response_') {
                  continue;
                }

                // If we have a current field and this isn't a checkbox line, add to value
                if (currentField && !line.startsWith('- [x]')) {
                  currentValue.push(line);
                }
              }
              
              // Save last field
              if (currentField && currentValue.length > 0) {
                const fieldName = fieldMapping[currentField];
                if (fieldName) {
                  data[fieldName] = currentValue.join('\n').trim();
                }
              }

              // Convert data to YAML format
              const deviceData = {
                id: data.device_id,
                brand: data.brand,
                model: data.model,
                release_date: parseInt(data.release_date),
                cpu: {
                  brand: data.cpu_brand,
                  model: data.cpu_model,
                  tdp: parseInt(data.cpu_tdp),
                  cores: data.cpu_cores ? parseInt(data.cpu_cores) : undefined,
                  threads: data.cpu_threads ? parseInt(data.cpu_threads) : undefined,
                  base_clock_ghz: data.base_clock_ghz ? parseFloat(data.base_clock_ghz) : undefined,
                  boost_clock_ghz: data.boost_clock_ghz ? parseFloat(data.boost_clock_ghz) : undefined,
                  architecture: data.cpu_architecture,
                  socket_type: data.cpu_socket_type !== 'None' ? data.cpu_socket_type : undefined
                },
                memory: {
                  type: data.memory_type,
                  module_type: data.memory_module_type,
                  slots: parseInt(data.memory_slots),
                  max_capacity_gb: parseInt(data.maximum_memory_capacity_gb),
                  speed_mhz: parseInt(data.memory_speed_mhz)
                }
              };

              // Parse GPU models if present
              if (data.gpu_models) {
                deviceData.gpu = data.gpu_models.split('\n')
                  .filter(line => line.trim().startsWith('Type:'))
                  .map(line => {
                    const parts = line.split(',').map(p => p.trim());
                    const gpu = {};
                    parts.forEach(part => {
                      const [key, value] = part.split(':').map(s => s.trim());
                      if (key.toLowerCase() === 'type') gpu.type = value;
                      if (key.toLowerCase() === 'model') gpu.model = value;
                      if (key.toLowerCase() === 'vram') gpu.vram = value;
                    });
                    return gpu;
                  });
              }

              // Parse storage details
              if (data.storage_details) {
                deviceData.storage = data.storage_details.split('\n')
                  .filter(line => line.trim().startsWith('Type:'))
                  .map(line => {
                    const parts = line.split(',').map(p => p.trim());
                    const storage = {};
                    parts.forEach(part => {
                      const [key, value] = part.split(':').map(s => s.trim());
                      storage[key.toLowerCase().replace(/ /g, '_')] = value;
                    });
                    return storage;
                  });
              }

              // Add networking if present
              deviceData.networking = {
                wifi: data.wifi_standard ? {
                  standard: data.wifi_standard,
                  chipset: data.wifi_chipset,
                  bluetooth: data.bluetooth_version
                } : undefined,
                ethernet: data.ethernet_ports ? data.ethernet_ports.split('\n')
                  .filter(line => line.trim().startsWith('Type:'))
                  .map(line => {
                    const parts = line.split(',').map(p => p.trim());
                    const eth = {};
                    parts.forEach(part => {
                      const [key, value] = part.split(':').map(s => s.trim());
                      eth[key.toLowerCase().replace(/ /g, '_')] = value;
                    });
                    return eth;
                  }) : []
              };

              // Add ports and interfaces
              if (data.usb_ports) {
                deviceData.ports = {
                  usb: data.usb_ports.split('\n')
                    .filter(line => line.trim().startsWith('Type:'))
                    .map(line => {
                      const parts = line.split(',').map(p => p.trim());
                      const usb = {};
                      parts.forEach(part => {
                        const [key, value] = part.split(':').map(s => s.trim());
                        usb[key.toLowerCase().replace(/ /g, '_')] = value;
                      });
                      return usb;
                    })
                };
              }

              if (data.display_ports) {
                if (!deviceData.ports) deviceData.ports = {};
                deviceData.ports.display = data.display_ports.split('\n')
                  .filter(line => line.includes('Version:') || line.includes('Count:'))
                  .map(line => {
                    const parts = line.split(',').map(p => p.trim());
                    const display = {};
                    parts.forEach(part => {
                      const [key, value] = part.split(':').map(s => s.trim());
                      display[key.toLowerCase().replace(/ /g, '_')] = value;
                    });
                    return display;
                  });
              }

              // Add physical specifications
              deviceData.physical = {
                dimensions: data.dimensions,
                power_adapter: data.power_adapter
              };

              if (data.audio_jacks) {
                deviceData.physical.audio_jacks = parseInt(data.audio_jacks);
              }

              if (data.sd_card_reader) {
                deviceData.physical.sd_card_reader = data.sd_card_reader === 'Yes';
              }

              // Add additional info if present
              if (data.additional_info && data.additional_info !== '_No response_') {
                deviceData.additional_info = data.additional_info;
              }

              const yamlString = yaml.dump(deviceData, { indent: 2, skipInvalid: true });
              
              // Use the GitHub API to create/update the file
              const brand = data.brand.toLowerCase();
              const filePath = `data/devices/${brand}/${data.device_id}.yaml`;
              const branchName = `new-device/${data.device_id}`;

              // Get the current main branch SHA
              const mainRef = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: 'heads/main'
              });

              // Create a new branch from main
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: mainRef.data.object.sha
                });
              } catch (error) {
                if (error.status !== 422) { // 422 means branch already exists
                  throw error;
                }
              }

              // Create the file in the new branch
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: filePath,
                message: `Add device data for ${data.brand} ${data.model}`,
                content: Buffer.from(yamlString).toString('base64'),
                branch: branchName
              });
              
              // Create PR
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Add Device: ${data.brand} ${data.model}`,
                body: `Adds data for **${data.brand} ${data.model}** based on issue #${context.issue.number}.\n\nCloses #${context.issue.number}`,
                head: branchName,
                base: 'main'
              });
              
              // Add labels to PR
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['new-device', 'automated-pr']
              });
              
              // Comment on the issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `Thank you for your submission! A Pull Request has been created: #${pr.data.number}`
              });
            }
            
            // Run the PR creation
            await createPR(); 