import { load } from 'js-yaml';
import { readFileSync, writeFileSync, readdirSync } from 'fs';
import { join, resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import type { MiniPC } from '../src/types/minipc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface ProcessedData {
  devices: MiniPC[];
  metadata: {
    brands: string[];
    cpuBrands: string[];
    memoryTypes: string[];
    wifiStandards: string[];
    ethernetSpeeds: string[];
    storageTypes: string[];
    storageInterfaces: string[];
    tdpRange: { min: number; max: number };
    coreRange: { min: number; max: number };
    memorySpeedRange: { min: number; max: number };
  };
}

function validateMiniPC(data: any): data is MiniPC {
  // Basic validation of required fields
  if (!data.id || !data.brand || !data.model) {
    throw new Error('Missing required fields: id, brand, or model');
  }

  if (!data.cpu || !data.cpu.brand || !data.cpu.model || !data.cpu.cores || !data.cpu.tdp) {
    throw new Error('Missing or invalid CPU information');
  }

  if (!data.memory || !data.memory.type || !data.memory.speed) {
    throw new Error('Missing or invalid memory information');
  }

  if (!Array.isArray(data.storage)) {
    throw new Error('Storage must be an array');
  }

  if (!data.networking || !data.networking.wifi || !data.networking.ethernet) {
    throw new Error('Missing or invalid networking information');
  }

  return true;
}

function extractMetadata(devices: MiniPC[]): ProcessedData['metadata'] {
  const metadata = {
    brands: new Set<string>(),
    cpuBrands: new Set<string>(),
    memoryTypes: new Set<string>(),
    wifiStandards: new Set<string>(),
    ethernetSpeeds: new Set<string>(),
    storageTypes: new Set<string>(),
    storageInterfaces: new Set<string>(),
    tdpRange: { min: Infinity, max: -Infinity },
    coreRange: { min: Infinity, max: -Infinity },
    memorySpeedRange: { min: Infinity, max: -Infinity },
  };

  for (const pc of devices) {
    metadata.brands.add(pc.brand);
    metadata.cpuBrands.add(pc.cpu.brand);
    metadata.memoryTypes.add(pc.memory.type);
    metadata.wifiStandards.add(pc.networking.wifi.standard);
    
    pc.networking.ethernet.forEach(eth => {
      metadata.ethernetSpeeds.add(eth.speed);
    });

    pc.storage.forEach(storage => {
      metadata.storageTypes.add(storage.type);
      metadata.storageInterfaces.add(storage.interface);
    });

    metadata.tdpRange.min = Math.min(metadata.tdpRange.min, pc.cpu.tdp);
    metadata.tdpRange.max = Math.max(metadata.tdpRange.max, pc.cpu.tdp);
    
    metadata.coreRange.min = Math.min(metadata.coreRange.min, pc.cpu.cores);
    metadata.coreRange.max = Math.max(metadata.coreRange.max, pc.cpu.cores);
    
    metadata.memorySpeedRange.min = Math.min(metadata.memorySpeedRange.min, pc.memory.speed);
    metadata.memorySpeedRange.max = Math.max(metadata.memorySpeedRange.max, pc.memory.speed);
  }

  return {
    brands: [...metadata.brands].sort(),
    cpuBrands: [...metadata.cpuBrands].sort(),
    memoryTypes: [...metadata.memoryTypes].sort(),
    wifiStandards: [...metadata.wifiStandards].sort(),
    ethernetSpeeds: [...metadata.ethernetSpeeds].sort(),
    storageTypes: [...metadata.storageTypes].sort(),
    storageInterfaces: [...metadata.storageInterfaces].sort(),
    tdpRange: metadata.tdpRange,
    coreRange: metadata.coreRange,
    memorySpeedRange: metadata.memorySpeedRange,
  };
}

function generateTypeDefinitions(data: ProcessedData): string {
  return `// Generated by build-data.ts - DO NOT EDIT MANUALLY
export const BRANDS = ${JSON.stringify(data.metadata.brands)} as const;
export const CPU_BRANDS = ${JSON.stringify(data.metadata.cpuBrands)} as const;
export const MEMORY_TYPES = ${JSON.stringify(data.metadata.memoryTypes)} as const;
export const WIFI_STANDARDS = ${JSON.stringify(data.metadata.wifiStandards)} as const;
export const ETHERNET_SPEEDS = ${JSON.stringify(data.metadata.ethernetSpeeds)} as const;
export const STORAGE_TYPES = ${JSON.stringify(data.metadata.storageTypes)} as const;
export const STORAGE_INTERFACES = ${JSON.stringify(data.metadata.storageInterfaces)} as const;

export type Brand = typeof BRANDS[number];
export type CpuBrand = typeof CPU_BRANDS[number];
export type MemoryType = typeof MEMORY_TYPES[number];
export type WifiStandard = typeof WIFI_STANDARDS[number];
export type EthernetSpeed = typeof ETHERNET_SPEEDS[number];
export type StorageType = typeof STORAGE_TYPES[number];
export type StorageInterface = typeof STORAGE_INTERFACES[number];

export const RANGES = ${JSON.stringify({
    tdp: data.metadata.tdpRange,
    cores: data.metadata.coreRange,
    memorySpeed: data.metadata.memorySpeedRange,
  }, null, 2)} as const;
`;
}

async function main() {
  const dataDir = resolve(__dirname, '../data/devices');
  const outputDir = resolve(__dirname, '../src/generated');
  const devices: MiniPC[] = [];

  // Process each vendor directory
  for (const vendor of readdirSync(dataDir)) {
    const vendorDir = join(dataDir, vendor);
    if (!vendorDir.includes('.')) { // Skip files, only process directories
      for (const file of readdirSync(vendorDir)) {
        if (file.endsWith('.yaml')) {
          console.log(`Processing ${vendor}/${file}...`);
          const filePath = join(vendorDir, file);
          const content = readFileSync(filePath, 'utf-8');
          
          try {
            const data = load(content) as any;
            if (validateMiniPC(data)) {
              // Add metadata
              data._sourcePath = `${vendor}/${file}`;
              data._vendor = vendor;
              data._device = file.replace('.yaml', '');
              devices.push(data);
            }
          } catch (error) {
            console.error(`Error processing ${filePath}:`, error);
            process.exit(1);
          }
        }
      }
    }
  }

  // Extract metadata and create processed data
  const processedData: ProcessedData = {
    devices,
    metadata: extractMetadata(devices),
  };

  // Create output directory if it doesn't exist
  const { mkdir } = await import('fs/promises');
  await mkdir(outputDir, { recursive: true });

  // Write processed data
  writeFileSync(
    join(outputDir, 'data.json'),
    JSON.stringify(processedData, null, 2)
  );

  // Generate and write type definitions
  writeFileSync(
    join(outputDir, 'types.ts'),
    generateTypeDefinitions(processedData)
  );

  console.log(`Successfully processed ${devices.length} devices`);
  console.log('Generated files:');
  console.log('- src/generated/data.json');
  console.log('- src/generated/types.ts');
}

main().catch(error => {
  console.error('Build failed:', error);
  process.exit(1);
}); 